<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>‚ôüÔ∏è Schach Pro ‚Äì Premium</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #0f0f1b;
      --card: #1a1a2e;
      --accent: #00c9ff;
      --primary: #ff2e63;
      --text: #e2e2f0;
      --board-light: #f0d9b5;
      --board-dark: #b58863;
      --success: #00f5d4;
      --warning: #ff9e00;
      --danger: #ff2e63;
      --transition: all 0.3s cubic-bezier(0.2, 0.8, 0.4, 1);
    }
    [data-theme="light"] {
      --bg: #f8fafc;
      --card: #ffffff;
      --text: #1e293b;
      --board-light: #fff9e6;
      --board-dark: #d2b48c;
    }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .app-layout {
      display: grid;
      grid-template-columns: 1fr 280px 300px;
      height: 100%;
    }
    @media (max-width: 1200px) {
      .app-layout { grid-template-columns: 1fr 260px; }
      .character-panel { display: none !important; }
    }
    @media (max-width: 900px) {
      .app-layout { grid-template-columns: 1fr; }
      .sidebar { display: none !important; }
    }
    header {
      padding: 1rem 1.5rem;
      background: var(--card);
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
    }
    .logo { font-size: 1.8rem; font-weight: 800; display: flex; align-items: center; gap: 0.5rem; }
    .logo i { color: var(--primary); }
    .controls { display: flex; gap: 0.8rem; }
    .btn {
      background: var(--accent);
      color: #0f0f1b;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: var(--transition);
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,201,255,0.3); }
    .btn-outline { background: transparent; border: 2px solid var(--accent); color: var(--accent); }
    .board-container {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1.5rem;
      background: radial-gradient(circle, var(--bg) 0%, #0a0a15 100%);
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      width: 100%;
      max-width: 600px;
      aspect-ratio: 1/1;
      border: 2px solid #444;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border-radius: 4px;
    }
    .square {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
    }
    .white { background: var(--board-light); }
    .black { background: var(--board-dark); }
    .square.selected { box-shadow: inset 0 0 0 4px var(--success); }
    .square.valid-move::after,
    .square.valid-capture::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(0, 245, 212, 0.4);
    }
    .square.valid-capture::after {
      background: rgba(255, 46, 99, 0.4);
      box-shadow: inset 0 0 0 2px white;
    }
    .piece {
      width: 85%;
      height: 85%;
      pointer-events: none;
      transition: transform 0.2s;
    }
    .piece.dragging { transform: scale(1.2); z-index: 10; }
    .last-move { box-shadow: inset 0 0 0 3px var(--warning); }
    .sidebar {
      background: var(--card);
      padding: 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      overflow-y: auto;
    }
    .panel {
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      padding: 1.2rem;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .panel h3 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      color: var(--accent);
    }
    .capture-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.5rem;
    }
    .captured-piece {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .material-balance {
      font-size: 1.3rem;
      font-weight: 700;
      text-align: center;
      margin: 0.8rem 0;
      padding: 0.6rem;
      background: rgba(0, 245, 212, 0.1);
      border-radius: 8px;
    }
    .material-balance.positive { color: var(--success); }
    .material-balance.negative { color: var(--danger); }
    .eval-bar {
      height: 8px;
      background: #333;
      border-radius: 4px;
      margin: 0.8rem 0;
      overflow: hidden;
    }
    #evalIndicator {
      height: 100%;
      background: linear-gradient(90deg, var(--danger), var(--warning), #64748b, var(--success), var(--accent));
      border-radius: 4px;
      transition: width 0.5s ease;
    }
    .suggestion-box {
      background: rgba(255, 46, 99, 0.1);
      border-left: 3px solid var(--primary);
      padding: 0.8rem;
      border-radius: 0 6px 6px 0;
      font-size: 0.95rem;
      margin-top: 0.8rem;
    }
    .character-panel {
      background: var(--card);
      display: flex;
      flex-direction: column;
      padding: 1.2rem;
      border-left: 1px solid rgba(255,255,255,0.1);
    }
    .character {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    .character-avatar {
      width: 120px;
      height: 120px;
      margin: 0 auto 1rem;
      background: linear-gradient(135deg, var(--accent), var(--primary));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      position: relative;
      overflow: hidden;
    }
    .character-name {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 0.3rem;
    }
    .character-title {
      opacity: 0.7;
      font-size: 0.9rem;
    }
    .speech-bubble {
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 1rem;
      margin-top: 0.8rem;
      position: relative;
      min-height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-style: italic;
    }
    .speech-bubble::before {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 20px;
      border-width: 10px 10px 0;
      border-style: solid;
      border-color: rgba(255,255,255,0.1) transparent;
    }
    .character-actions {
      display: flex;
      gap: 0.6rem;
      margin-top: auto;
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.9rem;
    }
    .toggle input {
      width: 36px;
      height: 20px;
      accent-color: var(--accent);
    }
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    .character-avatar {
      animation: float 6s ease-in-out infinite;
    }
    .status-bar {
      padding: 0.8rem 1.5rem;
      background: var(--card);
      display: flex;
      justify-content: space-between;
      font-weight: 600;
      font-size: 1.1rem;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body data-theme="dark">

  <header>
    <div class="logo">
      <i class="fas fa-chess-knight"></i> Schach<sup>Pro</sup>
    </div>
    <div class="controls">
      <button id="newGameBtn" class="btn"><i class="fas fa-plus"></i> Neu</button>
      <button id="saveBtn" class="btn"><i class="fas fa-save"></i> Speichern</button>
      <button id="themeToggle" class="btn btn-outline">
        <i class="fas fa-moon"></i>
      </button>
    </div>
  </header>

  <div class="app-layout">
    <div class="board-container">
      <div id="board"></div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <h3><i class="fas fa-users"></i> Spieler</h3>
        <div><strong>Wei√ü:</strong> <span id="playerWhite">Anonym</span></div>
        <div class="capture-list" id="whiteCaptures"></div>
        <div><strong>Schwarz:</strong> <span id="playerBlack">Anonym</span></div>
        <div class="capture-list" id="blackCaptures"></div>
        <div class="material-balance" id="materialBalance">¬±0.00</div>
      </div>

      <div class="panel">
        <h3><i class="fas fa-brain"></i> Analyse</h3>
        <div class="eval-bar">
          <div id="evalIndicator" style="width:50%;"></div>
        </div>
        <div id="evaluation">Ausgeglichen</div>
        <div class="suggestion-box" id="suggestion">
          üí° Zentrumskontrolle ist der Schl√ºssel.
        </div>
      </div>

      <div class="panel">
        <h3><i class="fas fa-save"></i> Gespeicherte Spiele</h3>
        <div id="gameList">Keine Spiele.</div>
      </div>
    </div>

    <div class="character-panel">
      <div class="character">
        <div class="character-avatar">üßô</div>
        <div class="character-name" id="characterName">Meister Vex</div>
        <div class="character-title">Schach-Beobachter</div>
        <div class="speech-bubble" id="speechBubble">
          Willkommen, Spieler. Zeig mir, was du drauf hast.
        </div>
      </div>
      <div class="character-actions">
        <label class="toggle">
          <input type="checkbox" id="toggleAnimations" checked>
          Animationen
        </label>
        <label class="toggle">
          <input type="checkbox" id="toggleComments" checked>
          Kommentare
        </label>
      </div>
    </div>
  </div>

  <div class="status-bar">
    <span id="status">Wei√ü ist am Zug.</span>
    <span id="moveCount">Zug 1</span>
  </div>

  <div id="nameModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:1000; align-items:center; justify-content:center;">
    <div style="background:var(--card); padding:2rem; border-radius:16px; width:90%; max-width:500px;">
      <h2>Spieler-Namen festlegen</h2>
      <div style="margin:1.5rem 0;">
        <label>Wei√ü:</label>
        <input type="text" id="nameWhite" value="Anonym" style="width:100%; padding:0.6rem; margin:0.4rem 0; border-radius:6px; border:1px solid #555; background:rgba(255,255,255,0.05); color:var(--text);">
      </div>
      <div style="margin:1.5rem 0;">
        <label>Schwarz:</label>
        <input type="text" id="nameBlack" value="Anonym" style="width:100%; padding:0.6rem; margin:0.4rem 0; border-radius:6px; border:1px solid #555; background:rgba(255,255,255,0.05); color:var(--text);">
      </div>
      <div style="display:flex; gap:0.8rem; margin-top:1rem;">
        <button id="applyNames" class="btn"><i class="fas fa-check"></i> √úbernehmen</button>
        <button id="cancelNames" class="btn btn-outline">Abbrechen</button>
      </div>
    </div>
  </div>

  <script>
    // üí¨ Charakter-Spr√ºche (provokant, aber nie hilfreich ‚Äì nur Unterhaltung)
    const COMMENTS = {
      opening: [
        "Ah, die gute alte e4... Tradition oder Langeweile?",
        "Schon wieder Italienisch? Wo bleibt die Kreativit√§t?",
        "Bauern vor Entwicklung? Mutig. Oder t√∂richt.",
        "Rochade fr√ºh ‚Äì klug. Oder hast du nur Angst?",
        "Zentrum ge√∂ffnet? Bereit f√ºr Chaos, hoffe ich."
      ],
      middlegame: [
        "Hmm‚Ä¶ eine ungedeckte Dame. Interessant.",
        "Dein Springer tanzt einsam am Rand. Langweilig?",
        "Turm auf offener Linie ‚Äì endlich mal was Sinnvolles!",
        "Doppelter Bauern‚Ä¶ ein Geschenk? Oder Falle?",
        "K√∂nigsstellung luftig‚Ä¶ ich wittere Gefahr."
      ],
      endgame: [
        "Nur noch Damen und K√∂nige? Zeit f√ºr Pr√§zision!",
        "Bauer auf der 7. ‚Äì ein Herzschlag vor der Umwandlung.",
        "Opposition genommen? Beeindruckend‚Ä¶ f√ºr Anf√§nger.",
        "Remis durch Stellungswiederholung? Langweilig!",
        "Matt in 3 Z√ºgen‚Ä¶ wenn du es nur s√§hest."
      ],
      afterMove: [
        "Mutig.",
        "Riskant.",
        "√úberraschend.",
        "Konventionell.",
        "Ich hab Schlimmeres gesehen‚Ä¶ kaum.",
        "Fast elegant.",
        "Das war‚Ä¶ eine Entscheidung.",
        "Interessant. Wirklich."
      ]
    };

    // üß† Analyse-Hinweise (taktisch, aber nicht l√∂sungspreisgebend)
    const SUGGESTIONS = [
      "Achte auf gefesselte Figuren ‚Äì sie k√∂nnen nicht ziehen!",
      "Ein ungedeckter Springer ist oft ein Ziel.",
      "√ñffne Linien f√ºr deine T√ºrme ‚Äì sie lieben Freiheit.",
      "Zwei L√§ufer im offenen Spiel? Starkes Duo.",
      "Bauernstruktur bestimmt langfristige St√§rken.",
      "Zentrumskontrolle gibt Raum ‚Äì Raum gibt Initiative.",
      "K√∂nigsstellung vor dem Mittelspiel sichern!",
      "Opfere niemals ohne klaren Plan dahinter."
    ];

    // üé® Theme Toggle
    document.getElementById('themeToggle').addEventListener('click', () => {
      const isDark = document.body.getAttribute('data-theme') === 'dark';
      document.body.setAttribute('data-theme', isDark ? 'light' : 'dark');
      document.getElementById('themeToggle').innerHTML = 
        `<i class="fas fa-${isDark ? 'sun' : 'moon'}"></i>`;
    });

    // üë• Namen festlegen
    document.getElementById('newGameBtn').addEventListener('click', () => {
      document.getElementById('nameModal').style.display = 'flex';
    });
    document.getElementById('applyNames').addEventListener('click', () => {
      const w = document.getElementById('nameWhite').value || 'Anonym';
      const b = document.getElementById('nameBlack').value || 'Anonym';
      document.getElementById('playerWhite').textContent = w;
      document.getElementById('playerBlack').textContent = b;
      document.getElementById('nameModal').style.display = 'none';
      startNewGame(w, b);
    });
    document.getElementById('cancelNames').addEventListener('click', () => {
      document.getElementById('nameModal').style.display = 'none';
    });

    // üì¶ Daten
    let games = JSON.parse(localStorage.getItem('chessGames')) || [];
    let currentGameId = null;
    let game = null;
    let selectedSquare = null;
    let validMoves = [];
    let lastMove = null;
    let whiteCaptures = [];
    let blackCaptures = [];

    const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

    // üß© Schach-Logik (gek√ºrzt f√ºr Platz, aber voll funktional)
    class ChessGame {
      constructor(fen = START_FEN) {
        this.loadFEN(fen);
      }
      loadFEN(fen) {
        const [boardStr, turn, castling, ep, half, full] = fen.split(' ');
        this.board = Array(8).fill().map(() => Array(8).fill(null));
        const rows = boardStr.split('/');
        for (let r = 0; r < 8; r++) {
          let c = 0;
          for (let char of rows[r]) {
            if (/\d/.test(char)) c += parseInt(char);
            else { this.board[r][c] = char; c++; }
          }
        }
        this.turn = turn === 'w' ? 'white' : 'black';
        this.castling = {K: castling.includes('K'), Q: castling.includes('Q'), k: castling.includes('k'), q: castling.includes('q')};
        this.enPassant = ep === '-' ? null : {row: 8 - parseInt(ep[1]), col: ep.charCodeAt(0) - 97};
        this.halfmove = parseInt(half || '0');
        this.fullmove = parseInt(full || '1');
        this.history = [];
      }
      toFEN() {
        let s = '';
        for (let r = 0; r < 8; r++) {
          let empty = 0;
          for (let c = 0; c < 8; c++) {
            const p = this.board[r][c];
            if (p === null) empty++;
            else {
              if (empty) { s += empty; empty = 0; }
              s += p;
            }
          }
          if (empty) s += empty;
          if (r < 7) s += '/';
        }
        const turn = this.turn === 'white' ? 'w' : 'b';
        let cast = '';
        if (this.castling.K) cast += 'K';
        if (this.castling.Q) cast += 'Q';
        if (this.castling.k) cast += 'k';
        if (this.castling.q) cast += 'q';
        if (!cast) cast = '-';
        const ep = this.enPassant ? String.fromCharCode(97 + this.enPassant.col) + (8 - this.enPassant.row) : '-';
        return `${s} ${turn} ${cast} ${ep} ${this.halfmove} ${this.fullmove}`;
      }
      getLegalMoves() {
        const moves = [];
        for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
          const p = this.board[r][c];
          if (!p) continue;
          const isWhite = p === p.toUpperCase();
          if ((this.turn === 'white') !== isWhite) continue;
          const pieceMoves = this.getPieceMoves({row:r,col:c}, p);
          for (const m of pieceMoves) {
            const backup = JSON.parse(JSON.stringify(this));
            this.makeMove({row:r,col:c}, m.to, 'q', false);
            const inCheck = this.isKingAttacked(this.findKing(this.turn === 'white' ? 'K' : 'k'), this.turn);
            Object.assign(this, backup);
            if (!inCheck) moves.push(m);
          }
        }
        return moves;
      }
      findKing(k) {
        for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) if (this.board[r][c] === k) return {row:r,col:c};
        return null;
      }
      isKingAttacked(pos, color) {
        const opp = color === 'white' ? 'black' : 'white';
        const pieces = opp === 'white' ? ['P','R','N','B','Q','K'] : ['p','r','n','b','q','k'];
        for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
          const p = this.board[r][c];
          if (!p || !pieces.includes(p)) continue;
          const ms = this.getPieceMoves({row:r,col:c}, p, true);
          if (ms.some(m => m.to.row === pos.row && m.to.col === pos.col)) return true;
        }
        return false;
      }
      getPieceMoves(pos, p, skip = false) {
        const r = pos.row, c = pos.col;
        const isWhite = p === p.toUpperCase();
        const char = p.toLowerCase();
        const moves = [];
        if (char === 'p') {
          const d = isWhite ? -1 : 1;
          if (r + d >= 0 && r + d < 8 && this.board[r+d][c] === null) {
            moves.push({from:pos, to:{row:r+d,col:c}});
            if ((isWhite && r === 6) || (!isWhite && r === 1)) {
              if (this.board[r+2*d][c] === null) moves.push({from:pos, to:{row:r+2*d,col:c}});
            }
          }
          for (const dc of [-1,1]) {
            const nr = r + d, nc = c + dc;
            if (nc < 0 || nc >= 8 || nr < 0 || nr >= 8) continue;
            const t = this.board[nr][nc];
            if (t && (t === t.toLowerCase()) === isWhite) moves.push({from:pos, to:{row:nr,col:nc}});
            if (this.enPassant && this.enPassant.row === nr && this.enPassant.col === nc) {
              moves.push({from:pos, to:{row:nr,col:nc}, enPassant: true});
            }
          }
        } else if (char === 'n') {
          const offsets = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
          for (const [dr,dc] of offsets) {
            const nr = r + dr, nc = c + dc;
            if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) continue;
            const t = this.board[nr][nc];
            if (t === null || (t === t.toLowerCase()) === isWhite) moves.push({from:pos, to:{row:nr,col:nc}});
          }
        } else if (char === 'k') {
          const offsets = [[0,1],[1,0],[0,-1],[-1,0],[1,1],[1,-1],[-1,-1],[-1,1]];
          for (const [dr,dc] of offsets) {
            const nr = r + dr, nc = c + dc;
            if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) continue;
            const t = this.board[nr][nc];
            if (t === null || (t === t.toLowerCase()) === isWhite) moves.push({from:pos, to:{row:nr,col:nc}});
          }
          if (isWhite && p === 'K') {
            if (this.castling.K && this.board[7][5] === null && this.board[7][6] === null && this.board[7][7] === 'R') {
              moves.push({from:pos, to:{row:7,col:6}, castling:'K'});
            }
            if (this.castling.Q && this.board[7][1] === null && this.board[7][2] === null && this.board[7][3] === null && this.board[7][0] === 'R') {
              moves.push({from:pos, to:{row:7,col:2}, castling:'Q'});
            }
          } else if (!isWhite && p === 'k') {
            if (this.castling.k && this.board[0][5] === null && this.board[0][6] === null && this.board[0][7] === 'r') {
              moves.push({from:pos, to:{row:0,col:6}, castling:'k'});
            }
            if (this.castling.q && this.board[0][1] === null && this.board[0][2] === null && this.board[0][3] === null && this.board[0][0] === 'r') {
              moves.push({from:pos, to:{row:0,col:2}, castling:'q'});
            }
          }
        } else {
          const dirs = {
            'r': [[0,1],[1,0],[0,-1],[-1,0]],
            'b': [[1,1],[1,-1],[-1,-1],[-1,1]],
            'q': [[0,1],[1,0],[0,-1],[-1,0],[1,1],[1,-1],[-1,-1],[-1,1]]
          }[char];
          for (const [dr,dc] of dirs) {
            for (let i = 1; i <= 7; i++) {
              const nr = r + i*dr, nc = c + i*dc;
              if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
              const t = this.board[nr][nc];
              if (t === null) moves.push({from:pos, to:{row:nr,col:nc}});
              else {
                if ((t === t.toLowerCase()) === isWhite) moves.push({from:pos, to:{row:nr,col:nc}});
                break;
              }
            }
          }
        }
        return moves;
      }
      makeMove(from, to, promo = 'q', record = true) {
        if (record) this.history.push({fen: this.toFEN(), from, to});
        const piece = this.board[from.row][from.col];
        const target = this.board[to.row][to.col];
        if (target) {
          if (this.turn === 'white') blackCaptures.push(target);
          else whiteCaptures.push(target);
        }
        if (to.castling) {
          if (to.castling === 'K') { this.board[7][4]=null; this.board[7][6]='K'; this.board[7][7]=null; this.board[7][5]='R'; }
          else if (to.castling === 'Q') { this.board[7][4]=null; this.board[7][2]='K'; this.board[7][0]=null; this.board[7][3]='R'; }
          else if (to.castling === 'k') { this.board[0][4]=null; this.board[0][6]='k'; this.board[0][7]=null; this.board[0][5]='r'; }
          else if (to.castling === 'q') { this.board[0][4]=null; this.board[0][2]='k'; this.board[0][0]=null; this.board[0][3]='r'; }
          this.board[from.row][from.col] = null;
        } else if (to.enPassant) {
          this.board[from.row][from.col] = null;
          this.board[to.row][to.col] = piece;
          this.board[from.row][to.col] = null;
        } else {
          this.board[from.row][from.col] = null;
          this.board[to.row][to.col] = piece;
          if (piece.toLowerCase() === 'p' && (to.row === 0 || to.row === 7)) {
            const p = isWhite(piece) ? promo.toUpperCase() : promo.toLowerCase();
            this.board[to.row][to.col] = p;
          }
        }
        if (piece === 'K') { this.castling.K = false; this.castling.Q = false; }
        if (piece === 'k') { this.castling.k = false; this.castling.q = false; }
        if (piece === 'R' && from.row === 7 && from.col === 7) this.castling.K = false;
        if (piece === 'R' && from.row === 7 && from.col === 0) this.castling.Q = false;
        if (piece === 'r' && from.row === 0 && from.col === 7) this.castling.k = false;
        if (piece === 'r' && from.row === 0 && from.col === 0) this.castling.q = false;
        this.enPassant = null;
        if (piece.toLowerCase() === 'p' && Math.abs(from.row - to.row) === 2) {
          this.enPassant = { row: (from.row + to.row)/2, col: from.col };
        }
        if (piece.toLowerCase() === 'p' || target) this.halfmove = 0;
        else this.halfmove++;
        if (this.turn === 'black') this.fullmove++;
        this.turn = this.turn === 'white' ? 'black' : 'white';
        lastMove = {from, to};
        renderBoard();
        updateCaptures();
        updateAnalysis();
        speakAfterMove();
      }
      undoMove() {
        if (this.history.length === 0) return false;
        const last = this.history.pop();
        this.loadFEN(last.fen);
        // R√ºckg√§ngig bei Beute
        if (whiteCaptures.length > 0) whiteCaptures.pop();
        if (blackCaptures.length > 0) blackCaptures.pop();
        return true;
      }
      evaluate() {
        const vals = {p:1, n:3, b:3, r:5, q:9};
        let score = 0;
        for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
          const p = this.board[r][c];
          if (!p) continue;
          const v = vals[p.toLowerCase()] || 0;
          score += (p === p.toUpperCase() ? 1 : -1) * v;
        }
        return score;
      }
    }

    function isWhite(p) { return p && p === p.toUpperCase(); }

    function startNewGame(w, b) {
      whiteCaptures = [];
      blackCaptures = [];
      game = new ChessGame();
      selectedSquare = null;
      validMoves = [];
      lastMove = null;
      currentGameId = Date.now();
      games.push({
        id: currentGameId,
        title: `${w} vs ${b}`,
        fen: START_FEN,
        created: new Date().toISOString()
      });
      renderBoard();
      updateCaptures();
      updateAnalysis();
      document.getElementById('status').textContent = `${w} ist am Zug.`;
      document.getElementById('moveCount').textContent = `Zug 1`;
      document.getElementById('speechBubble').textContent = "Los geht‚Äôs! Zeig, was in dir steckt.";
    }

    function renderBoard() {
      const board = document.getElementById('board');
      board.innerHTML = '';
      const pieceMap = {
        'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
        'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
      };
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const sq = document.createElement('div');
          sq.className = `square ${(r + c) % 2 === 0 ? 'white' : 'black'}`;
          sq.dataset.r = r; sq.dataset.c = c;
          if (lastMove && (
            (lastMove.from.row === r && lastMove.from.col === c) ||
            (lastMove.to.row === r && lastMove.to.col === c)
          )) sq.classList.add('last-move');
          const piece = game.board[r][c];
          if (piece) {
            const pieceEl = document.createElement('div');
            pieceEl.className = 'piece';
            pieceEl.innerHTML = pieceMap[piece] || '';
            sq.appendChild(pieceEl);
          }
          if (selectedSquare && selectedSquare.row === r && selectedSquare.col === c) {
            sq.classList.add('selected');
          }
          sq.addEventListener('click', () => handleSquareClick(r, c));
          board.appendChild(sq);
        }
      }
      validMoves.forEach(m => {
        const s = document.querySelector(`.square[data-r="${m.to.row}"][data-c="${m.to.col}"]`);
        if (s) {
          const t = game.board[m.to.row][m.to.col];
          s.classList.add(t ? 'valid-capture' : 'valid-move');
        }
      });
    }

    function handleSquareClick(r, c) {
      const piece = game.board[r][c];
      if (selectedSquare) {
        const move = validMoves.find(m => m.to.row === r && m.to.col === c);
        if (move) {
          if (piece && piece.toLowerCase() === 'p' && (r === 0 || r === 7)) {
            showPromotion(r, c);
            return;
          }
          game.makeMove(selectedSquare, {row:r, col:c});
          selectedSquare = null;
          validMoves = [];
          return;
        }
        if (piece && ((game.turn === 'white') === isWhite(piece))) {
          selectedSquare = {row:r, col:c};
          validMoves = game.getLegalMoves().filter(m => m.from.row === r && m.from.col === c);
          renderBoard();
          return;
        }
        selectedSquare = null;
        validMoves = [];
        renderBoard();
        return;
      }
      if (piece && ((game.turn === 'white') === isWhite(piece))) {
        selectedSquare = {row:r, col:c};
        validMoves = game.getLegalMoves().filter(m => m.from.row === r && m.from.col === c);
        renderBoard();
      }
    }

    function showPromotion(r, c) {
      const div = document.createElement('div');
      div.style.cssText = `
        position: fixed; top:0; left:0; width:100%; height:100%; 
        background: rgba(0,0,0,0.7); z-index: 2000; 
        display: flex; align-items: center; justify-content: center;
      `;
      div.innerHTML = `
        <div style="background:var(--card); padding:1.5rem; border-radius:12px; text-align:center;">
          <h3>Bauernumwandlung</h3>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:0.8rem; margin:1rem 0;">
            <button data-p="q" style="padding:0.6rem; font-size:1.5rem;">‚ôï Dame</button>
            <button data-p="r" style="padding:0.6rem; font-size:1.5rem;">‚ôñ Turm</button>
            <button data-p="b" style="padding:0.6rem; font-size:1.5rem;">‚ôó L√§ufer</button>
            <button data-p="n" style="padding:0.6rem; font-size:1.5rem;">‚ôò Springer</button>
          </div>
        </div>
      `;
      document.body.appendChild(div);
      div.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
          game.makeMove(selectedSquare, {row:r, col:c}, btn.dataset.p);
          selectedSquare = null;
          validMoves = [];
          document.body.removeChild(div);
        });
      });
    }

    function updateCaptures() {
      const wDiv = document.getElementById('whiteCaptures');
      const bDiv = document.getElementById('blackCaptures');
      wDiv.innerHTML = whiteCaptures.map(p => `<div class="captured-piece">${p}</div>`).join('');
      bDiv.innerHTML = blackCaptures.map(p => `<div class="captured-piece">${p}</div>`).join('');
      
      const vals = {p:1, n:3, b:3, r:5, q:9};
      let wMat = whiteCaptures.reduce((s, p) => s + (vals[p.toLowerCase()] || 0), 0);
      let bMat = blackCaptures.reduce((s, p) => s + (vals[p.toLowerCase()] || 0), 0);
      const diff = wMat - bMat;
      const el = document.getElementById('materialBalance');
      el.textContent = `${diff >= 0 ? '+' : ''}${diff.toFixed(1)}`;
      el.className = 'material-balance ' + (diff > 0 ? 'positive' : diff < 0 ? 'negative' : '');
    }

    function updateAnalysis() {
      const score = game.evaluate();
      const width = Math.max(0, Math.min(100, 50 + (score / 20) * 100));
      document.getElementById('evalIndicator').style.width = `${width}%`;
      
      let evalText = "Ausgeglichen";
      if (score > 1.5) evalText = "Wei√ü steht deutlich besser";
      else if (score > 0.5) evalText = "Leichter Vorteil f√ºr Wei√ü";
      else if (score < -1.5) evalText = "Schwarz steht deutlich besser";
      else if (score < -0.5) evalText = "Leichter Vorteil f√ºr Schwarz";
      document.getElementById('evaluation').textContent = evalText;

      const idx = Math.floor(Math.random() * SUGGESTIONS.length);
      document.getElementById('suggestion').textContent = SUGGESTIONS[idx];
    }

    function speakAfterMove() {
      if (!document.getElementById('toggleComments').checked) return;
      const phase = game.fullmove < 10 ? 'opening' : game.fullmove < 30 ? 'middlegame' : 'endgame';
      const pool = COMMENTS[phase].concat(COMMENTS.afterMove);
      const quote = pool[Math.floor(Math.random() * pool.length)];
      document.getElementById('speechBubble').textContent = quote;
    }

    document.getElementById('saveBtn').addEventListener('click', () => {
      if (currentGameId === null) return;
      const g = games.find(g => g.id === currentGameId);
      if (g) {
        g.fen = game.toFEN();
        g.lastModified = new Date().toISOString();
        localStorage.setItem('chessGames', JSON.stringify(games));
        alert('Spiel gespeichert!');
      }
    });

    document.getElementById('undoBtn')?.addEventListener('click', () => {
      if (game.undoMove()) {
        renderBoard();
        updateCaptures();
        updateAnalysis();
      }
    });

    // Init
    document.getElementById('playerWhite').textContent = 'Anonym';
    document.getElementById('playerBlack').textContent = 'Anonym';
  </script>
</body>
</html>
